/******************************************************************************
 * Memember functions for data structure IoLocationMap
 ******************************************************************************/
/* Headers from vtrutil library */
#include "vtr_log.h"
#include "vtr_assert.h"
#include "vtr_time.h"

/* Headers from openfpgautil library */
#include "openfpga_digest.h"

#include "io_location_map.h"

/* begin namespace openfpga */
namespace openfpga {

/**************************************************
 * Public Accessors 
 *************************************************/
size_t IoLocationMap::io_index(const size_t& x,
                               const size_t& y,
                               const size_t& z,
                               const std::string& io_port_name) const {
  if (x >= io_indices_.size()) {
    return size_t(-1);
  }

  if (y >= io_indices_[x].size()) {
    return size_t(-1);
  }

  if (z >= io_indices_[x][y].size()) {
    return size_t(-1);
  }

  auto result = io_indices_[x][y][z].find(io_port_name);
  if (result == io_indices_[x][y][z].end()) {
    return size_t(-1);
  }

  return result->second;
}

void IoLocationMap::set_io_index(const size_t& x,
                                 const size_t& y,
                                 const size_t& z,
                                 const std::string& io_port_name,
                                 const size_t& io_index) {
  if (x >= io_indices_.size()) {
    io_indices_.resize(x + 1);
  }

  if (y >= io_indices_[x].size()) {
    io_indices_[x].resize(y + 1);
  }

  if (z >= io_indices_[x][y].size()) {
    io_indices_[x][y].resize(z + 1);
  }

  io_indices_[x][y][z][io_port_name] = io_index;
}

int IoLocationMap::write_to_xml_file(const std::string& fname,
                                     const bool& include_time_stamp,
                                     const bool& verbose) const {
  std::string timer_message = std::string("Write fabric I/O information to an XML file '") + fname + std::string("'");

  std::string dir_path = format_dir_path(find_path_dir_name(fname));

  /* Create directories */
  create_directory(dir_path);

  /* Start time count */
  vtr::ScopedStartFinishTimer timer(timer_message);

  /* Use default name if user does not provide one */
  VTR_ASSERT(true != fname.empty());

  /* Create a file handler*/
  std::fstream fp;
  /* Open a file */
  fp.open(fname, std::fstream::out | std::fstream::trunc);

  /* Validate the file stream */
  check_file_stream(fname.c_str(), fp);

  int err_code = 0;

  /* Write XML head */
  fp << "<!--" << std::endl;
  fp << "\t- FPGA Fabric I/O Information" << std::endl;
  fp << "\t- Generated by OpenFPGA" << std::endl;

  auto end = std::chrono::system_clock::now(); 
  std::time_t end_time = std::chrono::system_clock::to_time_t(end);
  if (include_time_stamp) {
    fp << "\t- Date: " << std::ctime(&end_time) ;
  }

  fp << "-->" << std::endl;
  fp << std::endl;

  fp << "<io_coordinates>\n";

  size_t io_cnt = 0;

  /* Walk through the fabric I/O location map data structure */
  for (size_t x = 0; x < io_indices_.size(); ++x) {
    for (size_t y = 0; y < io_indices_[x].size(); ++y) {
      for (size_t z = 0; z < io_indices_[x][y].size(); ++z) {
        for (const auto& name_id_pair : io_indices_[x][y][z]) {
          fp << "\t" << "<io pad=\"" << name_id_pair.first << "[" << name_id_pair.second << "]\"";
          fp << " " << "x=\"" << x << "\"";
          fp << " " << "y=\"" << y << "\"";
          fp << " " << "z=\"" << z << "\"";
          fp << "/>";
          fp << "\n";
          io_cnt++;
        }
      }
    }
  } 

  /* Print an end to the file here */
  fp << "</io_coordinates>\n";

  /* close a file */
  fp.close();

  VTR_LOGV(verbose,
           "Outputted %lu I/Os to XML file: %s\n",
           io_cnt,
           fname.c_str());

  return err_code;
}

} /* end namespace openfpga */
